//@version=6
strategy("Open Close Cross Strategy R5.1", shorttitle="OCC Strategy R5.1", overlay=true, 
     pyramiding=0, default_qty_type=strategy.percent_of_equity, default_qty_value=10, calc_on_every_tick=false) // Execute only after bar close

// === INPUTS ===
useRes      = input.bool(true, title="Use Alternate Resolution?")
intRes      = input.int(4, title="Multiplier for Alternate Resolution", minval=1)
stratRes    = timeframe.ismonthly ? str.tostring(timeframe.multiplier * intRes) + "M" :
              timeframe.isweekly ? str.tostring(timeframe.multiplier * intRes) + "W" :
              timeframe.isdaily ? str.tostring(timeframe.multiplier * intRes) + "D" :
              timeframe.isintraday ? str.tostring(timeframe.multiplier * intRes) : "60"

basisType   = input.string("SMMA", title="MA Type:", options=["SMA", "EMA", "DEMA", "TEMA", "WMA", "VWMA", "SMMA", "HullMA", "LSMA", "ALMA", "SSMA", "TMA"])
basisLen    = input.int(3, title="MA Period", minval=1)
adxLength   = input.int(12, title="ADX Length", minval=1)
adxfilter   = input.int(7, title="ADX filter", minval=1)

// Added a "price deviation threshold" parameter to decide whether to skip a signal
priceDeviationThreshold = input.float(5, title="Allowed Price Deviation (USD)", minval=0.0)

// === BASE FUNCTIONS ===
variant(type, src, len) =>
    if type == "EMA"
        ta.ema(src, len)
    else if type == "SMA"
        ta.sma(src, len)
    else
        ta.sma(src, len)

// === SERIES SETUP ===
closeSeries = variant(basisType, close, basisLen)
openSeries  = variant(basisType, open, basisLen)

// Security wrapper
reso(exp, use, res) => use ? request.security(syminfo.tickerid, res, exp, lookahead=barmerge.lookahead_on) : exp

// Alternate resolution series
closeSeriesAlt = reso(closeSeries, useRes, stratRes)
openSeriesAlt  = reso(openSeries, useRes, stratRes)

// === ADX FILTER ===
plusDM = math.max(high - high[1], 0)
minusDM = math.max(low[1] - low, 0)
plusDM := plusDM > minusDM ? plusDM : 0
minusDM := minusDM > plusDM ? minusDM : 0

smoothedPlusDM = ta.rma(plusDM, adxLength)
smoothedMinusDM = ta.rma(minusDM, adxLength)
tr = ta.atr(adxLength)
smoothedTR = ta.rma(tr, adxLength)

plusDI = (smoothedPlusDM / smoothedTR) * 100
minusDI = (smoothedMinusDM / smoothedTR) * 100
dx = math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100
adx = ta.rma(dx, adxLength)

// === Trading Conditions ===
xlong     = ta.crossover(closeSeriesAlt, openSeriesAlt) and adx > adxfilter
xshort    = ta.crossunder(closeSeriesAlt, openSeriesAlt) and adx > adxfilter
longCond  = xlong
shortCond = xshort

// --------------------------
// Used to store the non-reversal signal generated by the previous bar
// --------------------------
var float pendingSignalPrice = na  // Record the signal bar's close price
var bool  pendingSignalLong  = false
var bool  pendingSignalShort = false

// === Trade Execution & Decision ===
// Evaluate at bar close
if barstate.isconfirmed
    // Record the current position size before bar close
    float oldPosSize = strategy.position_size

    // If a long signal is generated
    if longCond
        // If there was an existing short position, indicating a reversal signal
        if oldPosSize < 0
            // Immediately close the short position and send an alert (reversal closure)
            strategy.close("short")
            alert("游닉 [BUY] (Reversal) Closed short | Price: " + str.tostring(close), alert.freq_once_per_bar_close)
        else
            // For a normal new signal: execute entry as per backtest logic and store in pending for the next bar's price deviation check
            strategy.entry("long", strategy.long)
            pendingSignalPrice := close
            pendingSignalLong  := true
            pendingSignalShort := false

    // If a short signal is generated
    if shortCond
        // If there was an existing long position, indicating a reversal signal
        if oldPosSize > 0
            // Immediately close the long position and send an alert (reversal closure)
            strategy.close("long")
            alert("游닉 [SELL] (Reversal) Closed long | Price: " + str.tostring(close), alert.freq_once_per_bar_close)
        else
            // For a normal new signal: execute entry as per backtest logic and store in pending for the next bar's price deviation check
            strategy.entry("short", strategy.short)
            pendingSignalPrice := close
            pendingSignalShort := true
            pendingSignalLong  := false

// --------------------------
// On the first tick of the next bar, for non-reversal (pending) signals, check price deviation and send an alert
if barstate.isnew
    if not na(pendingSignalPrice)
        float diff = math.abs(open - pendingSignalPrice)
        if diff <= priceDeviationThreshold
            if pendingSignalLong
                alert("游닉 [BUY] (Normal) Entry long | Price: " + str.tostring(open) + " (Deviation: " + str.tostring(diff) + ")", alert.freq_once_per_bar)
            if pendingSignalShort
                alert("游닉 [SELL] (Normal) Entry short | Price: " + str.tostring(open) + " (Deviation: " + str.tostring(diff) + ")", alert.freq_once_per_bar)
        // Clear pending state
        pendingSignalPrice := na
        pendingSignalLong  := false
        pendingSignalShort := false

// === Set Stop Loss & Target Profit (based on price) ===
slPoints  = input.float(30, title="Initial Stop Loss Points", minval=0)   // Default stop loss: 30 USDT
tpPoints  = input.float(30, title="Initial Target Profit Points", minval=0) // Default target profit: 30 USDT

longStop  = strategy.position_avg_price - slPoints
longLimit = strategy.position_avg_price + tpPoints
shortStop  = strategy.position_avg_price + slPoints
shortLimit = strategy.position_avg_price - tpPoints

strategy.exit("XL", from_entry="long", stop=longStop, limit=longLimit)
strategy.exit("XS", from_entry="short", stop=shortStop, limit=shortLimit)
